---
output:
  md_document:
    variant: markdown_github
---
<!-- README.md is generated from README.Rmd. Please edit that file -->

# dgirt

```{r, knitr-options, echo = FALSE}
# rmarkdown::render("~/projects/dgirt/README.Rmd")
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-")
```
dgirt is an R package for dynamic group-level IRT models, as developed in [Caughey and Warshaw
2014](http://pan.oxfordjournals.org/content/early/2015/02/04/pan.mpu021.full.pdf+html):

> Over the past eight decades, millions of people have been surveyed on their political opinions. Until recently,
> however, polls rarely included enough questions in a given domain to apply scaling techniques such as IRT
> models at the individual level, preventing scholars from taking full advantage of historical survey data. To
> address this problem, we develop a Bayesian group-level IRT approach that models latent traits at the level
> of demographic and/or geographic groups rather than individuals. We use a hierarchical model to borrow
> strength cross-sectionally and dynamic linear models to do so across time. The group-level estimates can
> be weighted to generate estimates for geographic units. This framework opens up vast new areas of
> research on historical public opinion, especially at the subnational level.

## Installation

```{r, install-dgirt}
if (packageVersion("devtools") < 1.6) {
  install.packages("devtools")
}
devtools::install_github("jamesdunham/dgirt@milestone")
```

Get updates by reinstalling. dgirt is in early stages and under development.
See [NEWS](NEWS.md).

## Quick start

  * `wrangle` prepares data
  * `dgirt` fits models
  * `poststratify` reweights estimates

## Use

`state_opinion` is a dataset included with `dgirt` in which rows correspond to survey
responses from individuals. 

```{r, load-and-attach}
library(dgirt)
data(state_opinion)
```

Data formatted in this way need to be restructured with the `wrangle` function.
We'll pass `state_opinion` to `wrangle`'s `data` argument, which takes a list of data
to be used in modeling. Our table of survey responses will be an element named
`level1`, for the lowest hierarchical level in the model. (Note: at the moment,
there are limitations on model specifications. Level-one data is required and a
second hierarchical level is optional.)

We'll use the `vars` argument to identify variables of importance in `data`
(e.g. which represent item responses). `vars` is a list of named character
vectors with (at least) these elements:

  * `items`: Names of item response variables $y_{iq}$ in `data$level1`.
  * `groups`: Names of respondent characteristic variables in `data$level1`.
     (Note: at this time, `wrangle` requires that the user exclude the
     geographic indicator from `groups` and name it instead in `geo_id`. 
     Modeling any group predictor is coming.)
  * `time_id`: Name of time period variable in `data$level1`.
  * `geo_id`: Name of geographic identifier variable in `data$level1`.
  * `survey_id`: Name of survey identifier variable in `data$level1`.
  * `survey_weight`: Name of weight variable $w_i$ in `data$level1`.

The names of the item response variables start with "q\_", so we'll
pass them using `grep`.

```{r, wrangle}
state_opinion_fmt = wrangle(
  data = list(level1 = state_opinion),
  vars = list(items = grep("^Q_", colnames(state_opinion), value = TRUE),
              groups = c("female", "race"),
              time_id = "year",
              geo_id = "state",
              survey_id = "source",
              survey_weight = "weight"))
```

`wrangle` returns a list of objects that `dgirt` expects as its first argument.
We'll also set its `n_iter` and `n_chain` arguments to minimize its run time,
but otherwise rely on the defaults.

```{r, dgirt-rstan}
dgirt_estimates = dgirt(state_opinion_fmt, n_iter = 10, n_chain = 1)
```

`dgirt` calls `rstan`, which reports any problems it encounters when
compiling the model and sampling. If sampling is successful, `dgirt` 
returns a `stanfit` object. 

To extract samples from the result of `dgirt` we can use `extract_dgirt`, which
returns a list whose elements are named arrays and matrices containing
estimates of model parameters. We'll take a look at `theta_bar`, the group
means ($\\bar{\\theta}_g$).

```{r, dgirt-extract}
dgirt_extract = extract_dgirt(dgirt_estimates)
str(dgirt_extract$theta_bar)
```

`theta_bar` is 3 $\\times$ 9 $\\times$ 306:

  * The first dimension of the array is indexed by sampler iteration. We ran
    the sampler for 10 iterations and by default discarded 7 as warm-ups, so
    this dimension is length-3.
  * The array's second dimension is indexed by time period, here the nine years
    2006-2014.
  * The third dimension, indexed by covariate combination, is length-306, or
    2 $\\times$ 3 $\\times$ 51. We have 2 levels in our first covariate
    `D_gender`, 3 levels (excluding `NA`) in our second covariate `D_race_new`,
    and 51 levels in the geographic identifier.

## `cmdstan`

We can use the `method` argument of `dgirt` to choose an alternative to MCMC
sampling if `cmdstan` is available. See
http://mc-stan.org/interfaces/cmdstan.html for installation instructions. For
example, setting `method = "optimize"` will call `cmdstan optimize`.

```{r, dgirt-optimize}
point_estimates = dgirt(state_opinion_fmt, n_iter = 100, n_chain = 1, method = "optimize", init_range = 0.5)
head(point_estimates$theta_bar)
```

## `poststratify`

```{r, load-demograhpics}
data(state_demographics)
head(state_demographics)
```

```{r, poststratify}
# theta_bars = point_estimates$theta_bar %>%
#   dplyr::rename(female = group_1, race = group_2, year = t) %>%
#   dplyr::mutate(year = as.integer(year), geo = as.factor(geo), female = as.factor(female), race = as.factor(race))
# group_means = poststratify(
#   group_means = theta_bars,
#   targets =  state_demographics, 
#   variables = "year",
#   prop_var = "proportion")
```
