#' Estimate a DGIRT model
#'
<<<<<<< HEAD
#' `dgirt` makes a call to `\link[rstan]{stan}` with the Stan code and data for
#' a DGIRT model. By default the call overrides the `stan` defaults for `pars`
#' to specify typical DGIRT parameters of interest and sets `iter_r` to `1L`.
#'
#' Additional arguments giving modeling choices:
#'
#' \describe{
#'   \item{separate_t}{Whether smoothing of estimates over time should be
#'   disabled. Default `FALSE`.}
#'   \item{delta_tbar_prior_mean}{Prior mean for `delta_tbar`, the normal weight
#'   on `theta_bar` in the previous period.  Default `0.5`.}
#'   \item{delta_tbar_prior_sd}{Prior standard deviation for `delta_bar`.
#'   Default `0.5`.}
#'   \item{innov_sd_delta_scale}{Prior scale for `sd_innov_delta`, the Cauchy
#'   innovation standard deviation of `nu_geo` and `delta_gamma`. Default
#'   `2.5`.}
#'   \item{innov_sd_theta_scale}{Prior scale for `sd_innov_theta`, the Cauchy
#'   innovation standard deviation of `gamma`, `xi`, and if `constant_item` is
#'   `FALSE` the item difficulty `diff`. Default `2.5`.}
#' }
#'
#' @param shaped_data Output from `shape`.
#' @param ... Further arguments to `\link[rstan]{stan}`.
#' @return A `dgirtfit` object that extends `\link[rstan]{stanfit-class}`. For
#' details see `\link{dgirtfit-class}`.
#' @import rstan
#' @export
#' @include constants.r
dgirt <- function(shaped_data, ...) {

  dots <- list(...,
               file = system.file("inst/dgirt.stan", package = "dgirt", mustWork = TRUE),
               data = shaped_data$as_list(...))
  if (!length(dots$pars)) {
    dots$pars <- c("theta_bar", "xi", "gamma", "delta_gamma", "delta_tbar",
              "nu_geo", "nu_geo_prior", "kappa", "sd_item", "sd_theta",
              "sd_theta_bar", "sd_gamma", "sd_innov_gamma", "sd_innov_delta",
              "sd_innov_logsd", "sd_total", "theta_l2", "var_theta_bar_l2")
=======
#' @param dgirt_data Data prepared for use with `dgirt` by `wrangle`.
#' @param n_iter See \code{iter} in \code{rstan::stan}.
#' @param n_chain See \code{chains} in \code{rstan::stan}.
#' @param n_warm See \code{warmup} in \code{rstan::stan}.
#' @param max_save Maximum iterations to save; only used in the default value of n_thin.
#' @param n_thin See \code{thin} in \code{rstan::stan}.
#' @param init_range See \code{init} in \code{rstan::stan}.
#' @param seed See \code{seed} in \code{rstan::stan}.
#' @param save_pars See \code{pars} in \code{rstan::rstan_options}
#' @param parallel See \code{rstan::rstan_options(auto_write = parallel)}.
#' @param method By default, `rstan::stan` estimates the model using MCMC
#'        sampling. Alternatively, `cmdstan optimize` or `cmdstan variational`
#'        can be used if CmdStan is available. Note that these methods
#'        are faster than MCMC sampling but return only point estimates.
#'        See \url{http://mc-stan.org/interfaces/cmdstan.html} for CmdStan
#'        installation instructions.
#' @param optimize_algorithm The optimization algorithm for CmdStan to use if
#'        `method` is `"optimize"`, one of `"bfgs"`, `"lbfgs"` (the default),
#'        and `"newton"`. See CmdStan documentation for details.
#' @param ... Additional arguments passed to `rstan::stan`.
#' @return An object of S4 class `stanfit` as returned by `rstan::stan`.
#' @import rstan
#' @export
dgirt <- function(dgirt_data, n_iter = 2000, n_chain = 2, max_save = 2000, n_warm = min(10000,
    floor(n_iter * 3 / 4)), n_thin = ceiling((n_iter - n_warm) / (max_save / n_chain)), init_range = 1,
  seed = 1, save_pars = c("theta_bar", "xi", "gamma", "delta_gamma", "delta_tbar", "nu_geo",
    "nu_geo_prior", "kappa", "sd_item", "sd_theta", "sd_theta_bar", "sd_gamma", "sd_innov_gamma",
    "sd_innov_delta", "sd_innov_logsd", "sd_total", "theta_l2", "var_theta_bar_l2"),
  parallel = TRUE, method = "rstan", algorithm = NULL, ...) {

  requireNamespace("rstan", quietly = TRUE)
  rstan::rstan_options(auto_write = parallel)
  if (parallel) {
      options(mc.cores = parallel::detectCores())
  }

  if (length(save_pars) < 1) stop("save_pars gives no parameters to save")

  vars = dgirt_data$vars
  dgirt_data$vars = NULL
  group_counts = dgirt_data$group_counts
  dgirt_data$group_counts = NULL

  assertthat::assert_that(is_subset(method, c("rstan", "optimize", "variational")))
  message("Started: ", date())
  stan_out <- switch(method,
    rstan = use_rstan(dgirt_data, n_iter, n_chain, n_warm, n_thin, save_pars, seed, init_range, vars, ...),
    optimize = use_cmdstan(dgirt_data, method, algorithm = 'lbfgs', n_iter, init_range, save_pars, vars),
    variational = use_cmdstan(dgirt_data, method, algorithm = 'meanfield', n_iter, init_range, save_pars, vars))
  message("Ended: ", date())

  return(stan_out)
}

use_rstan <- function(dgirt_data, n_iter, n_chain, n_warm, n_thin, save_pars, seed, init_range, vars, ...) {
  message("Running ", n_iter, " iterations in each of ", n_chain, " chains. Thinning at an interval of ",
    n_thin, " with ", n_warm, " adaptation iterations.")
  stan_out <- rstan::stan(model_code = stan_code, data = dgirt_data, iter = n_iter,
    chains = n_chain, warmup = n_warm, thin = n_thin, verbose = FALSE, pars = save_pars,
    seed = seed, init = "random", init_r = init_range, ...)
  return(stan_out)
}

use_cmdstan <- function(dgirt_data, method, algorithm, n_iter, init_range, save_pars, vars) {
  dump_dgirt(dgirt_data)
  stan_args <- paste0(method, " algorithm=", algorithm, " iter=", n_iter, " init='", init_range,
    "' data file=", get_dump_path(), " output file=", get_output_path())
  assertthat::assert_that(assertthat::is.readable(get_dgirt_path()))
  system2(get_dgirt_path(), stan_args)
  unlink(get_dump_path())
  if (file.exists(get_output_path())) {
    stan_output <- read_cmdstan_output(get_output_path(), save_pars)
    stan_output <- filter_cmdstan_output(stan_output, save_pars)
    stan_output <- name_output_dims(stan_output, vars)
    return(stan_output)
  } else {
    warning("cmdstan didn't write an output file; check its output for errors.")
    return(NULL)
>>>>>>> master
  }
  if (!length(dots$init_r)) {
    dots$init_r <- 1L
  }
  dots <- dots[!names(dots) %in% dgirt_pars]

  stanfit <- do.call(rstan::stan, dots)

<<<<<<< HEAD
  tryCatch(new("dgirtFit", stanfit, dgirt_in = shaped_data, call = match.call()),
           error = function(e) {
             warning("Error constructing dgirtfit; returning stanfit object instead")
             stanfit
           })
=======
attach_t = function(element, use_t, time_id) {
  assertthat::assert_that(identical(nrow(element) %% length(use_t), 0L))
  dplyr::mutate_(element, .dots = setNames(list(~rep(use_t, nrow(element) / length(use_t))), time_id))
>>>>>>> master
}
